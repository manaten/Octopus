\documentclass[a4j, twocolumn]{jarticle}

\title {JavaScript 実装系 v8 における\\ICの仕組みとその効果}
\author{加藤 真人( 05 06768 )  指導教員  脇田 建}
\date {}

%\renewcommand{\baselinestretch}{0.9}

\begin {document}
\maketitle
\section{序論}
 今日, Web技術は日々進化し, Webブラウザによって行うことのできる作業は増加している. 
 数年前では静的なWebページを受動的に見ることしかできなかったが, 
 現在ではWebページ上で日記を書いたり, ドキュメントを作成したりといったことが可能になっている. 
 それらの多くは、Webブラウザに処理系が搭載されるJavaScriptと言う言語により実装される. 
 JavaScrptはスクリプト言語であることに加え他のメジャーな言語とは違った個性的な特徴を持ち、
 その高速な実装には工夫が必要である。
 本論文では, 昨年リリースされたGoogle社のChromeに搭載される、
 高速なJavaScriptの実行系であるV8について論じる. 
 そしてV8に施されたJavaScriptの実行の仕組みの工夫について述べ, 
 その中からICという機構について詳しく述べる. 

 \section{JavaScript実装上の問題点と解決法}
  JavaScriptは, その性質ゆえに高速な実装が難しいものとなっている. 

  まず、JavaScriptはスクリプト言語である。
  スクリプト言語は、ソースコードを直に実行系に与えて即座に実行するものである。
  より、そのままではネイティブ言語のようなアセンブリコードによる実行はできない。
  
  それに対する解決方法として、動的コード変換がある。
  動的にソースコードをバイトコードやアセンブリコードに変換し、ネイティブ言語に近い性能を得る。
  実行箇所ごとに実行直前に変換を行うJITコンパイルというものもある。
  
  また、プロパティの探索にも問題がある。
  JavaScriptは動的型付け言語であり, 動的にプロパティの数が増減する可能性が
  ある。そのためレシーバの位置からの静的なオフセット値を得ることができないので、
  静的型付け言語に比べプロパティアクセスのパフォーマンスが悪い. 
  加えてJavaScriptはプロトタイプ指向のオブジェクト指向であり、
  継承に似たプロトタイプという機構を持ち、プロトタイプのオブジェクトの
  プロパティをアクセスする時にさらにパフォーマンスが悪くなってしまう。
  
  それに対してはプロパティの探索結果のキャッシュと言う解決方法がある。
  コストの高いプロパティ探索を回避するために、プロパティごとに探索結果をキャッシュに保持する。
  そのプロパティが別のレシーバの型に対して呼ばれない限り、高い効果を発揮する。

  キャッシュをさらに発展させた方法がインラインキャッシュである\cite{679193}。
  以下ICと表記する。
  実行中でのある地点で呼ばれるプロパティのレシーバの型に局所性があることを利用し、
  プロパティ探索をしたのちにその結果を直接呼ぶコードを呼び出し地点のコードと書き換える。
  もし違うレシーバの型に対して呼ばれた場合は、再び探索をしてコードを書き換える。
  その地点のプロパティが複数の型に対して頻繁に呼ばれない限り高い効果を発揮する。
   
  さらに、複数の型に対するプロパティに対しても効果を発揮できるようにしたものがPolymorphicICである。
  以下PICと表記する。
  こちらは、キャッシュされたプロパティが別のレシーバの型に対して呼ばれた場合、
  さらにその探索結果もキャッシュに残し、以後は
  それぞれのレシーバ型に対して一致するキャッシュを利用するようになる。 
  一致するものがなければ再び探索をしてキャッシュを作る。

\section{V8}
 この章ではV8について解説する。
 Chromeは全体的にユーザーレスポンスの良さに重点を置いて開発されており, 
 高速にブラウザを動作させるための工夫が施されている. 
 JavaScriptエンジンについても同様で, V8は非常に高速に動作する. 
 
 V8はJavaScriptの高速処理のため, 次の特徴を持つ\cite{dev8}.
 \begin{itemize}
 \item
  Hidden class。
  JavaScriptのオブジェクトはクラスを持たないが、V8では
  オブジェクトそれぞれにHidden classを割り当てる. 
  オブジェクトにプロパティが新たに追加されるごとに生成され、
  Hidden classの持つオフセット値によりプロパティにアクセスできる。
 \item
  IC。
  V8は, PolymorphicICを採用し、プロパティアクセスを高速にしている.
 \item
  動的機械語生成。
  V8ではJITコンパイラを用いてJavaScriptのコードをアセンブリコードへ翻訳し実行する. 
  V8は生成されたアセンブリコードを書き換えることによってICを実現する. 
 \item
  ガベージコレクション。
  V8は必要なメモリ領域が足りなくなった時に世代別ガーベジコレクションを行う. 
 \end{itemize}
 本論文ではこれらのV8の特徴のうち, ICの仕組みについて説明する. 


\section{V8でのICの実装}
 V8のICはPICである。
 しかし前述のPICとは少し違う構造をしている。
 V8のICは呼び出しごとに状態が変わっていき、それぞれの段階に名前がつけられている。
 
 一番初め、未実行のコードの実行をすると、premonomorphic状態のスタブコードを生成し、
 以降の呼び出しをこのコードを経由するように書き換えたのち、プロパティの探索をし、実行する。
  
 premonomorphic状態のICに対して呼び出しがあると、
 プロパティの探索をし、その結果を埋め込んだmonomorphic状態のスタブコードを生成し、
 移行の実行をこのコードに書き換える。その後プロパティを実行する。

 monomorphic状態のICは単一のキャッシュを保持する。
 この状態のコードに呼び出しがあると、レシーバの型チェックをし、
 一致すれば保持されたキャッシュを実行する。
 一致しなければ再度探索を行い、
 megamorphic状態のスタブコードを生成し、移行の実行をこのコードに書き換え、探索結果を実行する。
 
 megamorphic状態では複数のキャッシュを保持する。
 今まで呼ばれた事のあるレシーバの型情報とキャッシュのペアを保持し、
 呼ばれたレシーバの型に対応するキャッシュを実行する。
 一致する型が無かった場合、探索を行い、キャッシュリストに追加し、実行する。
  
 V8ではこのようなキャッシュ状態の遷移の他、プロパティの呼び出し形式が
 関数呼び出しか、変数のロードか、変数のストアかによっても実行するICのコードが変わる。
 これは、それぞれの操作に特化したコードを与えるほか、経験的なそれぞれの呼び出され型の違いも
 キャッシュの効率を上げるために利用している。

\section{まとめ}
 本論文ではJavaScriptの実行効率を上げるための工夫を延べ、
 その中でもICの仕組みを大きく取り上げた。
 さらにその一例としてGoogle V8の実装を取り上げた。
 IC自体、経験則的な知識に基づく技法であり、
 加えてV8では、呼び出し形式の違いなどによる改良も加えられ、
 より経験則に基づいた高速化技術を実装している。

\raggedright
\renewcommand{\baselinestretch}{0.7}
\bibliographystyle {jplain}
\bibliography {paper}

\end {document}
